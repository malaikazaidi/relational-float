#lang racket

(require rackunit rackunit/text-ui "mk.rkt" "float.rkt" "mk-float.rkt" "test-numbers.rkt")
(provide create-mk-length< create-mk-length> create-mk-length= check-mk-pred check-mk-length> check-mk-length< check-mk-length= check-fp-equal?
         check-list-fp-equal? check-results-fp-equal? check-results-list-fp-equal? run/time test/fp-relation-r)

(define FEW-RESULTS-MSG "There are not enough results!")
(define GREAT-RESULTS-MSG "There are too many results!")
(define NEQ-RESULTS-MSG "There are too many or too few results!")

(define (both-empty? l1 l2)
    (and (equal? (length l1) (length l2)) (equal? (length l1) 0)))

(define (create-mk-length< n)
    (lambda (run-result) (< (length run-result) n)))

(define (create-mk-length> n)
    (lambda (run-result) (> (length run-result) n)))

(define (create-mk-length= n)
    (lambda (run-result) (equal? (length run-result) n)))

#|
(mk-result-check-pred run-result pred msg)
    run-result: A list generated by a miniKanren run statement.
    pred: a function that takes in a run result and returns #true on pass, #f on failure
    msg: A message to be displayed on failure.

    Checks if the (pred run-result) -> #t.
|#
(define-check (check-mk-pred run-result pred msg)
    (unless (pred run-result) (fail-check msg)))

#|
(mk-result-check-length< run-result n)
    run-result: A list generated by a miniKanren run statement.
    n: A strict upper bound on the number of results.

    Checks if the number of results is strictly less than n.
|#
(define-check (check-mk-length< run-result n)
    (check-mk-pred run-result (create-mk-length< n) GREAT-RESULTS-MSG))

#|
(mk-result-check-length> run-result n)
    run-result: A list generated by a miniKanren run statement.
    n: A strict lower bound on the number of results.

    Checks if the number of results is strictly less than n.
|#
(define-check (check-mk-length> run-result n)
    (check-mk-pred run-result (create-mk-length> n) FEW-RESULTS-MSG))

#|
(check-mk-length= run-result n)
    run-result: A list generated by a miniKanren run statement.
    n: the number of expected results

    Checks if the number of results in run-result equals n.
|#
(define-check (check-mk-length= run-result n) 
    (let* ([actual-number-of-results (length run-result)]
           [fewer? (< actual-number-of-results n)]
           [greater? (> actual-number-of-results n)]) 
          (cond 
            [fewer? (fail-check FEW-RESULTS-MSG)]
            [greater? (fail-check GREAT-RESULTS-MSG)]
            [else (void)])))

#|
(err-msg-folder msg acc)
    msg: the next potential error msg
    acc: The current error msg string.

    When used by foldl it will interleave 'AND' between each string.
|#
(define/match (err-msg-folder msg acc)
 [("" acc) acc]
 [(msg acc) (string-append acc " AND " msg)])

#|
(build-err-msg msgs)
    msgs: a list of strings.

    If s_0, s_1, ..., s_n are the strings contained in msgs, then we return the string 
    "s_0 AND s_1 AND s_2 ... AND s_n".
|#
(define (build-err-msg msgs)
    (foldl err-msg-folder (first msgs) (rest msgs)))


#|
(examine-fps fp1 fp2)
    fp1: A mkfp number.
    fp2: A mkfp number.

    Compares each floating number component by component and returns
    a string indicating whether they are equal or differ at a certain component. 
|#
(define (examine-fps fp1 fp2)
    (let* ([sign1 (get-sign fp1)]
           [sign2 (get-sign fp2)]
           [sign-equal? (equal? sign1 sign2)]
           [sign-msg (if sign-equal? "" "SIGNS NOT EQUAL")]

           [man1 (get-frac fp1)]
           [man2 (get-frac fp2)]
           [man-equal? (equal? man1 man2)]
           [man-msg (if man-equal? "" "MANTISSA NOT EQUAL")]
           
           [exp1 (get-exp fp1)]
           [exp2 (get-exp fp2)]
           [exp-equal? (equal? exp1 exp2)]
           [exp-msg (if exp-equal? "" "EXPONENTS NOT EQUAL")]

           [msgs (filter (lambda (msg) (not (equal? "" msg))) (list sign-msg exp-msg man-msg))]

           [equal (and sign-equal? man-equal? exp-equal?)]) 
        (cond
         [equal "eq"]
         [else (build-err-msg msgs)])))

#|
(check-fp-equal? fp1 fp2)
    fp1: A miniKanren floating point number
    fp2: A miniKanren floating point number

    A check that determines if fp1 == fp2. If they are not equal, the error msg says exactly what is not equal.
|#
(define-check (check-fp-equal? fp1 fp2)
    (let* ([examination-result (examine-fps fp1 fp2)])
          (cond
            [(equal? examination-result "eq") (void)]
            [else (fail-check examination-result)])))

#|
(check-list-fp-helper fp1s fp2s n)

Driver function for (check-list-fp-equal? fp1s fp2s).
|#
(define-check (check-list-fp-helper fp1s fp2s n)
    (cond 
        [(both-empty? fp1s fp2s) (void)]
        [else (let* ([fp1-first (first fp1s)]
                     [fp2-first (first fp2s)]

                     [examination-result (examine-fps fp1-first fp2-first)]
                     [equal (equal? examination-result "eq")]
                     [fail-msg (string-append "Fp at index: " (number->string n) "\n" examination-result)]) 
        
                (cond
                    [equal (check-list-fp-helper (rest fp1s) (rest fp2s))] ; we know at least the forst two match
                    [else (fail-check fail-msg)]))]))

#|
(check-list-fp-equal? fp1s fp2s)
    fp1s: A list of mkfp numbers.
    fp2s: A list of mkfp numbers

A check to determine where the two parallel lists of mk
|#
(define-check (check-list-fp-equal? fp1s fp2s)
    (check-list-fp-helper fp1s fp2s 0))

(define-check (check-results-fp-equal? results fp)
    (check-fp-equal? (first results) fp))

(define-check (check-results-list-fp-equal? results fps)
    (check-list-fp-equal? (first results) fps))



#|
(run/time <name> : <constraint-expr> (<lvar> <lvars> ...))     ; Finds 1 answer
(run/time <name> : <constraint-expr> <n> (<lvar> <lvars> ...)) ; Finds up to n answers
(run/time <name> : <constraint-expr> * (<lvar> <lvars> ...))  ; Finds all answers
|#
(define-syntax run/time
    (syntax-rules (: *)

     [(run/time <name> : <constraint-expr> (<lvar> <lvars> ...))
        (begin
            (displayln (string-append "\n" "Running: " <name>))
            (time (run 1 (<lvar> <lvars> ...) <constraint-expr>)))]
     [(run/time <name> : <constraint-expr> <n> (<lvar> <lvars> ...))
        (begin
            (displayln (string-append "\n" "Running: " <name>))
            (time (run <n> (<lvar> <lvars> ...) <constraint-expr>)))]
     [(run/time <name> : <constraint-expr> * (<lvar> <lvars> ...))
        (begin
            (displayln (string-append "\n" "Running: " <name>))
            (time (run* (<lvar> <lvars> ...) <constraint-expr>)))]))

(define-syntax test/fp-relation-r 
    (syntax-rules ()
        [(test/fp-relation-r <test-name> (<relation-expr> (<lvar> <lvars> ...)) (<check> <check-args> ...) ...)
         (test-case <test-name>
         (let* ([results (run/time <test-name> : 
                                 <relation-expr> (<lvar> <lvars> ...))])
              (check-mk-length= results 1)
              (<check> (if (equal? <check-args> 'results) results <check-args>) ... ) ...
              ))]
        [(test/fp-relation-r <test-name> <n> <expected-n> (<relation-expr> (<lvar> <lvars> ...)) (<check> <check-args> ...) ...)
        (test-case <test-name>
         (let* ([results (run/time <test-name> : 
                                 <relation-expr> <n> (<lvar> <lvars> ...))])
              (check-mk-length= results <expected-n>)
              (<check> (if (equal? <check-args> 'results) results <check-args>) ... ) ...))]))

(define test 
    (test-suite "macro check"

        (test/fp-relation-r "x*1 = 2" ((fp-multo x one two) (x))
            (check-results-fp-equal? 'results two))
        (test/fp-relation-r "x*y = 1" ((fp-multo x y one) (x y))
            (check-results-list-fp-equal? 'results (list one one)))))

;(run-tests test 'verbose) 