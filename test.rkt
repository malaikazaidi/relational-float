#lang racket

(require rackunit rackunit/text-ui "mk.rkt" "float.rkt" "mk-float.rkt" "test-numbers.rkt")
(provide create-mk-length< create-mk-length> create-mk-length= check-mk-pred check-mk-length> check-mk-length< check-mk-length= check-fp-equal?
         run/time test/fp-relation-r)

(define FEW-RESULTS-MSG "There are not enough results!")
(define GREAT-RESULTS-MSG "There are too many results!")
(define NEQ-RESULTS-MSG "There are too many or too few results!")

(define (create-mk-length< n)
    (lambda (run-result) (< (length run-result) n)))

(define (create-mk-length> n)
    (lambda (run-result) (> (length run-result) n)))

(define (create-mk-length= n)
    (lambda (run-result) (equal? (length run-result) n)))

#|
(mk-result-check-pred run-result pred msg)
    run-result: A list generated by a miniKanren run statement.
    pred: a function that takes in a run result and returns #true on pass, #f on failure
    msg: A message to be displayed on failure.

    Checks if the (pred run-result) -> #t.
|#
(define-check (check-mk-pred run-result pred msg)
    (unless (pred run-result) (fail-check msg)))

#|
(mk-result-check-length< run-result n)
    run-result: A list generated by a miniKanren run statement.
    n: A strict upper bound on the number of results.

    Checks if the number of results is strictly less than n.
|#
(define-check (check-mk-length< run-result n)
    (check-mk-pred run-result (create-mk-length< n) GREAT-RESULTS-MSG))

#|
(mk-result-check-length> run-result n)
    run-result: A list generated by a miniKanren run statement.
    n: A strict lower bound on the number of results.

    Checks if the number of results is strictly less than n.
|#
(define-check (check-mk-length> run-result n)
    (check-mk-pred run-result (create-mk-length> n) FEW-RESULTS-MSG))

#|
(check-mk-length= run-result n)
    run-result: A list generated by a miniKanren run statement.
    n: the number of expected results

    Checks if the number of results in run-result equals n.
|#
(define-check (check-mk-length= run-result n) 
    (let* ([actual-number-of-results (length run-result)]
           [fewer? (< actual-number-of-results n)]
           [greater? (> actual-number-of-results n)]) 
          (cond 
            [fewer? (fail-check FEW-RESULTS-MSG)]
            [greater? (fail-check GREAT-RESULTS-MSG)]
            [else (void)])))

#|
(err-msg-folder msg acc)
    msg: the next potential error msg
    acc: The current error msg string.

    When used by foldl it will interleave 'AND' between each string.
|#
(define/match (err-msg-folder msg acc)
 [("" acc) acc]
 [(msg acc) (string-append acc " AND " msg)])

#|
(build-err-msg msgs)
    msgs: a list of strings.

    If s_0, s_1, ..., s_n are the strings contained in msgs, then we return the string 
    "s_0 AND s_1 AND s_2 ... AND s_n".
|#
(define (build-err-msg msgs)
    (foldl err-msg-folder (first msgs) (rest msgs)))

#|
(check-fp-equal? fp1 fp2)
    fp1: A miniKanren floating point number
    fp2: A miniKanren floating point number

    A check that determines if fp1 == fp2. If they are not equal, the error msg says exactly what is not equal.
|#
(define-check (check-fp-equal? fp1 fp2)
    (let* ([sign1 (get-sign fp1)]
           [sign2 (get-sign fp2)]
           [sign-equal? (equal? sign1 sign2)]
           [sign-msg (if sign-equal? "" "SIGNS NOT EQUAL")]

           [man1 (get-frac fp1)]
           [man2 (get-frac fp2)]
           [man-equal? (equal? man1 man2)]
           [man-msg (if man-equal? "" "MANTISSA NOT EQUAL")]
           
           [exp1 (get-exp fp1)]
           [exp2 (get-exp fp2)]
           [exp-equal? (equal? exp1 exp2)]
           [exp-msg (if exp-equal? "" "EXPONENTS NOT EQUAL")]

           [msgs (filter (lambda (msg) (not (equal? "" msg))) (list sign-msg exp-msg man-msg))]

           [equal (and sign-equal? man-equal? exp-equal?)])
          (if equal 
            (void)
            (fail-check (build-err-msg msgs)))))

#|
(run/time <name> : <constraint-expr> (<lvar> <lvars> ...))     ; Finds 1 answer
(run/time <name> : <constraint-expr> <n> (<lvar> <lvars> ...)) ; Finds up to n answers
(run/time <name> : <constraint-expr> * (<lvar> <lvars> ...))  ; Finds all answers
|#
(define-syntax run/time
    (syntax-rules (: *)

     [(run/time <name> : <constraint-expr> (<lvar> <lvars> ...))
        (begin
            (displayln (string-append "\n" "Running: " <name>))
            (time (run 1 (<lvar> <lvars> ...) <constraint-expr>)))]
     [(run/time <name> : <constraint-expr> <n> (<lvar> <lvars> ...))
        (begin
            (displayln (string-append "\n" "Running: " <name>))
            (time (run <n> (<lvar> <lvars> ...) <constraint-expr>)))]
     [(run/time <name> : <constraint-expr> * (<lvar> <lvars> ...))
        (begin
            (displayln (string-append "\n" "Running: " <name>))
            (time (run* (<lvar> <lvars> ...) <constraint-expr>)))]))

#|
(test/fp-relation-r <test-name> <expected> : <relation-expr> (<lvar> <lvars> ...)) ; Runs for 1 answer and ensures there is one answer.
(test/fp-relation-r <test-name> <n> <expected-m> <expected> : <relation-expr> (<lvar> <lvars> ...)) ; Runs for n answers and ensures m answers are found.
|#          
(define-syntax test/fp-relation-r
    (syntax-rules (:) 
     [(test/fp-relation-r <test-name> <expected> : <relation-expr> (<lvar> <lvars> ...))
        (test-case <test-name>
         (let* ([result (run/time <test-name> : 
                                 <relation-expr> (<lvar> <lvars> ...))])
              (check-mk-length= result 1)
              (check-fp-equal? (first result) <expected>)))]
     [(test/fp-relation-r <test-name> <n> <expected-n> <expected> : <relation-expr> (<lvar> <lvars> ...))
        (test-case <test-name>
         (let* ([result (run/time <test-name> : 
                                 <relation-expr> <n> (<lvar> <lvars> ...))])
              (check-mk-length= result <expected-n>)
              (check-fp-equal? (first result) <expected>)))]))

(define test 
    (test-suite "macro check"

        (test/fp-relation-r "1 + 1 = ?" two : (fp-pluso one one x) (x))
        (test/fp-relation-r "2 + 1 = ?" three : (fp-pluso one two x) (x))
        (test/fp-relation-r "42 + 4 = ?" p46 : (fp-pluso fortytwo four x) (x))
        (test/fp-relation-r "72 + 60 = ?" p132 : (fp-pluso seventytwo sixty x) (x))
        (test/fp-relation-r "-4 + -1 = ?" n5 : (fp-pluso negfour negone x) (x))
        (test/fp-relation-r "-4 + -70 = ?" n74 : (fp-pluso negfour negseventy x) (x))
        (test/fp-relation-r "-421 + -1 = ?" n422 : (fp-pluso neg421 negone x) (x))
        (test/fp-relation-r "2.5 + 3 = ?" p5.5 : (fp-pluso p2.5 three x) (x))
        (test/fp-relation-r "2.5 + 3.25 = ?" p5.75 : (fp-pluso p2.5 p3.25 x) (x))
        (test/fp-relation-r "1.05 + 3.2325 = ?" p4.2825 : (fp-pluso p1.05 p3.2325 x) (x))
        (test/fp-relation-r "-4 + -9 = ?" n13 :(fp-pluso negfour n9 x) (x))

        (test/fp-relation-r "2 + ? = 3" one : (fp-pluso two x three) (x))
        (test/fp-relation-r "? + 2 = 3" one : (fp-pluso x two three) (x))
        (test/fp-relation-r "42 + ? = 46" four : (fp-pluso fortytwo x p46) (x))
        (test/fp-relation-r "? + 42 = 46" four : (fp-pluso x fortytwo p46) (x))
        (test/fp-relation-r "72 + ? = 132" sixty : (fp-pluso seventytwo x p132) (x))
        (test/fp-relation-r "? + 72 = 132" sixty : (fp-pluso x seventytwo p132) (x))
        (test/fp-relation-r "-4 + ? = -5" negone : (fp-pluso negfour x n5) (x))
        (test/fp-relation-r "? + -4 = -5" negone : (fp-pluso x negfour n5) (x))
        #;(test/fp-relation-r "-421 + ? = -422" negone : (fp-pluso neg421 x n422) (x)) ; these take ridculously long +15 minutes
        #;(test/fp-relation-r "? + -421 = -422" negone : (fp-pluso x neg421 n422) (x))
        (test/fp-relation-r "-10.12 + ? = -33.365" n23.245 : (fp-pluso n10.12 x n33.365) (x))
        (test/fp-relation-r "? + -10.12 = -33.365" n23.245 : (fp-pluso x n10.12 n33.365) (x))
    ))

;(run-tests test 'verbose)